console.log('[MAIN] Starting imports...');

const TelegramBot = require('node-telegram-bot-api');
console.log('[MAIN] TelegramBot imported');

const cron = require('node-cron');
console.log('[MAIN] cron imported');

const db = require('./database');
console.log('[MAIN] database imported');

const adminHandlers = require('./admin-handlers-final');
console.log('[MAIN] admin-test imported, type:', typeof adminHandlers);
console.log('[MAIN] adminHandlers.handleAdminTasks type:', typeof adminHandlers.handleAdminTasks);

// Bot token - should be set via environment variable
const token = process.env.BOT_TOKEN || '8379368723:AAEnG133OZ4qMrb5vQfM7VdEFSuLiWydsyM';

// First, try to delete webhook and then use polling
const bot = new TelegramBot(token, { polling: false });

// Clear any existing webhook and enable polling
async function initializeBotMode() {
    try {
        console.log('üîÑ Clearing any existing webhook...');
        await bot.deleteWebHook();
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second

        console.log('üîÑ Starting polling mode...');
        await bot.startPolling({ restart: true });
        console.log('‚úÖ Bot polling started successfully!');
    } catch (error) {
        console.error('‚ùå Error initializing bot mode:', error);
        throw error;
    }
}

// Admin configuration
const ADMIN_ID = 6910097562;
const ADMIN_CHANNEL = process.env.ADMIN_CHANNEL || '@kirbyvivodstars';

// Initialize database and bot
async function startBot() {
    try {
        console.log('üöÄ Starting Telegram bot with PostgreSQL...');
        await db.initializeDatabase();
        await initializeBotMode();
        console.log('‚úÖ Bot started successfully!');
    } catch (error) {
        console.error('‚ùå Error starting bot:', error);
        process.exit(1);
    }
}

// Helper function to check if user is admin
function isAdmin(userId) {
    return userId === ADMIN_ID;
}

// Helper function to get required channels from database
async function getRequiredChannels() {
    try {
        const result = await db.executeQuery('SELECT channel_id FROM required_channels WHERE is_active = TRUE');
        return result.rows.map(row => row.channel_id);
    } catch (error) {
        console.error('Error getting required channels:', error);
        return [];
    }
}

// Helper function to check if user is subscribed to all required channels (enhanced)
async function checkAllSubscriptions(userId) {
    const requiredChannels = await getRequiredChannels();
    if (requiredChannels.length === 0) return true;
    
    try {
        for (const channel of requiredChannels) {
            try {
                const member = await bot.getChatMember(channel, userId);
                if (member.status === 'left' || member.status === 'kicked') {
                    return false;
                }
            } catch (error) {
                // If bot can't check membership (private channel or no admin rights), auto-approve
                console.log(`Auto-approving subscription for channel ${channel} due to access restriction`);
                continue;
            }
        }
        return true;
    } catch (error) {
        console.error('Error checking subscriptions:', error);
        return false;
    }
}

// Legacy function for backward compatibility
async function checkSubscriptions(userId) {
    return await checkAllSubscriptions(userId);
}

// Helper function to get subscription message with channel links
async function getSubscriptionMessage() {
    let message = 'üîî –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã:\n\n';
    let buttons = [];
    
    try {
        const result = await db.executeQuery('SELECT channel_id, channel_name FROM required_channels WHERE is_active = TRUE');
        result.rows.forEach((channel, index) => {
            message += `${index + 1}. ${channel.channel_name || channel.channel_id}\n`;
            
            // Create button for each channel
            const channelLink = channel.channel_id.startsWith('@') ? 
                `https://t.me/${channel.channel_id.substring(1)}` : 
                channel.channel_id;
            
            buttons.push([{ text: `üì∫ ${channel.channel_name || channel.channel_id}`, url: channelLink }]);
        });
    } catch (error) {
        console.error('Error getting channel data:', error);
    }
    
    message += '\nüìå –ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞';
    buttons.push([{ text: '‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏', callback_data: 'check_subscriptions' }]);
    
    return { message, buttons };
}

// Main menu text response
function getMainMenuText() {
    return `üåü **–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é StarBot**

üí∞ **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**

üë§ **/profile** - –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å
üë• **/invite** - –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–∑–µ–π
üéØ **/clicker** - –µ–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞
‚≠ê **/withdraw** - –≤—ã–≤–æ–¥ –∑–≤—ë–∑–¥
üìã **/tasks** - –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏–π
üìñ **/instruction** - –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –±–æ—Ç—É
üèÜ **/ratings** - —Ä–µ–π—Ç–∏–Ω–≥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
üéÅ **/cases** - –ø—Ä–∏–∑–æ–≤—ã–µ –∫–µ–π—Å—ã
üé∞ **/lottery** - —É—á–∞—Å—Ç–∏–µ –≤ –ª–æ—Ç–µ—Ä–µ—è—Ö
üéÅ **/promocode** - –≤–≤–æ–¥ –ø—Ä–æ–º–æ–∫–æ–¥–∞

üí° **–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω—É–∂–Ω—É—é –∫–æ–º–∞–Ω–¥—É!**`;
}

// Start command handler
bot.onText(/\/start(.*)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const user = msg.from;
    const referralCode = match ? match[1].trim() : null;
    
    try {
        // Check if user exists
        let dbUser = await db.getUser(userId);
        
        if (!dbUser) {
            // New user - create user first
            dbUser = await db.createOrUpdateUser(user);
            
            // Check for referral only after user is registered and subscribed
            if (referralCode && !isNaN(referralCode)) {
                const referrer = await db.getUser(parseInt(referralCode));
                if (referrer) {
                    // Store referral info temporarily, will be processed after subscription
                    await db.updateUserField(userId, 'pending_referrer', parseInt(referralCode));
                }
            }
        }
        
        // Check subscriptions
        const isSubscribed = await checkAllSubscriptions(userId);
        const requiredChannels = await getRequiredChannels();

        if (!isSubscribed && requiredChannels.length > 0) {
            const subData = await getSubscriptionMessage();
            
            await bot.sendMessage(chatId, subData.message, {
                reply_markup: { inline_keyboard: subData.buttons }
            });
            return;
        }
        
        // User is subscribed - update subscription status
        await db.updateUserField(userId, 'is_subscribed', true);
        
        // Process pending referral if exists
        if (dbUser.pending_referrer) {
            const invitedBy = dbUser.pending_referrer;
            
            // Update referrer stats
            await db.executeQuery(
                'UPDATE users SET referrals_count = referrals_count + 1, referrals_today = referrals_today + 1, balance = balance + 3 WHERE id = $1',
                [invitedBy]
            );
            
            // Clear pending referrer
            await db.updateUserField(userId, 'pending_referrer', null);
            await db.updateUserField(userId, 'invited_by', invitedBy);

            // Send notification to referrer
            try {
                const message = `üéâ **–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!**

üë§ –ü–æ –≤–∞—à–µ–π —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: **${user.first_name}**

üí∞ **–í—ã –ø–æ–ª—É—á–∏–ª–∏:** +3 ‚≠ê
üíé **–í–∞—à –±–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω!**

üë• –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –¥—Ä—É–∑–µ–π –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –µ—â–µ –±–æ–ª—å—à–µ –∑–≤—ë–∑–¥!`;

                await bot.sendMessage(invitedBy, message, {
                    parse_mode: 'Markdown'
                });
            } catch (error) {
                console.error('Error sending referral notification:', error);
            }
        }
        
        // Send main menu
        const welcomeMessage = `üåü **–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ StarBot!**

üí∞ **–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è –∑–∞—Ä–∞–±–æ—Ç–∫–∞ Telegram Stars**

üéØ **–î–æ—Å—Ç—É–ø–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
‚Ä¢ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã –≤ –∫–ª–∏–∫–µ—Ä–µ
‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏–π –∑–∞ –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ
‚Ä¢ –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ (3‚≠ê –∑–∞ –¥—Ä—É–≥–∞)
‚Ä¢ –£—á–∞—Å—Ç–∏–µ –≤ –ª–æ—Ç–µ—Ä–µ—è—Ö –∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∞—Ö
‚Ä¢ –û—Ç–∫—Ä—ã—Ç–∏–µ –ø—Ä–∏–∑–æ–≤—ã—Ö –∫–µ–π—Å–æ–≤

${getMainMenuText()}`;

        await bot.sendMessage(chatId, welcomeMessage, {
            parse_mode: 'Markdown'
        });

    } catch (error) {
        console.error('Error in start command:', error);
        bot.sendMessage(chatId, '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
});

// Profile command
bot.onText(/\/profile/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        if (!user) {
            await bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
            return;
        }

        const registrationDate = new Date(user.registered_at).toLocaleDateString('ru-RU');
        const totalEarned = user.referrals_count * 3;

        const message = `üë§ **–õ–∏—á–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å**

üÜî **–ò–Ω—Ñ–æÔøΩÔøΩ–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ:**
‚Ä¢ –ò–º—è: **${user.first_name}**
‚Ä¢ ID: \`${user.id}\`
‚Ä¢ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: **${registrationDate}**

üí∞ **–§–∏–Ω–∞–Ω—Å–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
‚Ä¢ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: **${user.balance} ‚≠ê**
‚Ä¢ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: **${totalEarned} ‚≠ê**

üë• **–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:**
‚Ä¢ –í—Å–µ–≥–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–æ: **${user.referrals_count}**
‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ —Å–µ–≥–æ–¥–Ω—è: **${user.referrals_today}**

üéØ **–ò–≥—Ä–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
${user.last_click ? `‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–π –∫–ª–∏–∫: ${new Date(user.last_click).toLocaleDateString('ru-RU')}` : '‚Ä¢ –ö–ª–∏–∫–µ—Ä –µ—â–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è'}
${user.last_case_open ? `‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–π –∫–µ–π—Å: ${new Date(user.last_case_open).toLocaleDateString('ru-RU')}` : '‚Ä¢ –ö–µ–π—Å—ã –µ—â–µ –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–ª–∏—Å—å'}

üí° **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:** /invite /promocode`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in profile:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è.');
    }
});

// Invite command
bot.onText(/\/invite/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        if (!user) {
            await bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
            return;
        }

        // Get bot username
        let botUsername = 'starsbotexample';
        try {
            const botInfo = await bot.getMe();
            botUsername = botInfo.username;
        } catch (error) {
            console.error('Error getting bot info:', error);
        }

        const inviteLink = `https://t.me/${botUsername}?start=${user.id}`;

        const message = `üåü **–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞**

üí∞ **–ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –≤–º–µ—Å—Ç–µ —Å –¥—Ä—É–∑—å—è–º–∏!**
–ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ **3 ‚≠ê** –∑–∞ –∫–∞–∂–¥–æ–≥–æ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!

üîó **–í–∞—à–∞ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:**
\`${inviteLink}\`

üìä **–°—Ç–∞—ÇÔøΩÔøΩ—Å—Ç–∏–∫–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π:**
üë• –í—Å–µ–≥–æ –¥—Ä—É–∑–µ–π –ø—Ä–∏–≥–ª–∞—à–µ–Ω–æ: **${user.referrals_count}**
üìÖ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ —Å–µ–≥–æ–¥–Ω—è: **${user.referrals_today}**
üí∞ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: **${user.referrals_count * 3} ‚≠ê**

üéØ **–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:**
1. –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π —Å –¥—Ä—É–∑—å—è–º–∏
2. –î—Ä—É–≥ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è –ø–æ —Å—Å—ã–ª–∫–µ
3. –î—Ä—É–≥ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
4. –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ 3 ‚≠ê –Ω–∞ –±–∞–ª–∞–Ω—Å!

‚ö†Ô∏è **–í–∞–∂–Ω–æ:** –†–µ—Ñ–µ—Ä–∞–ª –∑–∞—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in invite:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã.');
    }
});

// Clicker command
bot.onText(/\/clicker/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        if (!user) {
            await bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
            return;
        }

        const now = new Date();
        const lastClick = user.last_click ? new Date(user.last_click) : null;
        const canClick = !lastClick || now.toDateString() !== lastClick.toDateString();

        if (canClick) {
            const reward = 0.1;
            await db.updateUserBalance(user.id, reward);
            await db.updateUserField(user.id, 'last_click', now);

            const message = `üéØ **–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–ª–∏–∫–µ—Ä**

üéâ **–û—Ç–ª–∏—á–Ω–æ!** –í—ã –ø–æ–ª—É—á–∏–ª–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É!
üí∞ –ù–∞—á–∏—Å–ª–µ–Ω–æ: **+${reward} ‚≠ê**

üíé **–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:** ${user.balance + reward} ‚≠ê

‚è∞ **–°–ª–µ–¥—É—é—â–∞—è –Ω–∞–≥—Ä–∞–¥–∞:** –∑–∞–≤—Ç—Ä–∞ –≤ —ç—Ç–æ –∂–µ –≤—Ä–µ–º—è
üïê –ù–µ –∑–∞–±—É–¥—å—Ç–µ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∑–∞ –Ω–æ–≤–æ–π –Ω–∞–≥—Ä–∞–¥–æ–π!`;

            await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        } else {
            const nextClick = new Date(lastClick);
            nextClick.setDate(nextClick.getDate() + 1);
            nextClick.setHours(0, 0, 0, 0);

            const timeUntilNext = nextClick - now;
            const hoursLeft = Math.floor(timeUntilNext / (1000 * 60 * 60));
            const minutesLeft = Math.floor((timeUntilNext % (1000 * 60 * 60)) / (1000 * 60));

            const message = `üéØ **–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–ª–∏–∫–µ—Ä**

‚è∞ **–ù–∞–≥—Ä–∞–¥–∞ —É–∂–µ –ø–æ–ª—É—á–µ–Ω–∞ —Å–µ–≥–æ–¥–Ω—è!**

üí∞ **–í–∞—à –±–∞–ª–∞–Ω—Å:** ${user.balance} ‚≠ê

‚è≥ **–î–æ —Å–ª–µ–¥—É—é—â–µ–π –Ω–∞–≥—Ä–∞–¥—ã:** ${hoursLeft}—á ${minutesLeft}–º
üéÅ **–°–ª–µ–¥—É—é—â–∞—è –Ω–∞–≥—Ä–∞–¥–∞:** 0.1 ‚≠ê

üí° **–°–æ–≤–µ—Ç:** –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ 3 ‚≠ê –∑–∞ –∫–∞–∂–¥–æ–≥–æ!`;

            await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        }

    } catch (error) {
        console.error('Error in clicker:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∫–ª–∏–∫–µ—Ä–∞.');
    }
});

// Withdraw command
bot.onText(/\/withdraw/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        if (!user) {
            await bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
            return;
        }

        const message = `‚≠ê **–í—ã–≤–æ–¥ –∑–≤—ë–∑–¥**

**–í–∞—à –±–∞–ª–∞–Ω—Å:** ${user.balance} ‚≠ê

${user.referrals_count < 5 ? 
    '‚ùå **–î–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ä–µ–¥—Å—Ç–≤ —Ç—Ä–µ–±—É—é—Ç—Å—è –º–∏–Ω–∏–º—É–º 5 —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤**' : 
    '‚úÖ **–í—ã –º–æ–∂–µ—Ç–µ –≤—ã–≤–æ–¥–∏—Ç—å —Å—Ä–µ–¥—Å—Ç–≤–∞**'
}

**–î–æ—Å—Ç—É–ø–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –≤—ã–≤–æ–¥–∞:**
‚Ä¢ **/withdraw15** - 15 ‚≠ê
‚Ä¢ **/withdraw25** - 25 ‚≠ê  
‚Ä¢ **/withdraw50** - 50 ‚≠ê
‚Ä¢ **/withdraw100** - 100 ‚≠ê
‚Ä¢ **/withdrawpremium** - Telegram Premium (1300 ‚≠ê)

–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω—É–∂–Ω—É—é –∫–æ–º–∞–Ω–¥—É!`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in withdraw:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –≤—ã–≤–æ–¥–∞.');
    }
});

// Withdraw amount commands
async function handleWithdrawCommand(msg, amount, type = 'stars') {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        
        if (user.referrals_count < 5) {
            await bot.sendMessage(chatId, '‚ùå –î–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ä–µ–¥—Å—Ç–≤ —Ç—Ä–µ–±—É—é—Ç—Å—è –º–∏–Ω–∏–º—É–º 5 —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤!');
            return;
        }

        if (user.balance < amount) {
            await bot.sendMessage(chatId, '‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ!');
            return;
        }

        // Create withdrawal request
        await db.executeQuery(
            'INSERT INTO withdrawal_requests (user_id, amount, type) VALUES ($1, $2, $3)',
            [userId, amount, type]
        );

        // Deduct from balance
        await db.updateUserBalance(userId, -amount);

        // Send notification to admin channel
        const adminMessage = `üîî **–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –≤—ã–≤–æ–¥**

üë§ **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** ${user.first_name}
üÜî **ID:** ${user.id}
${user.username ? `üì± **Username:** @${user.username}` : ''}
üîó **–°—Å—ã–ª–∫–∞:** [–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ—Ñ–∏–ª—å](tg://user?id=${user.id})

üí∞ **–°—É–º–º–∞:** ${amount} ‚≠ê
üì¶ **–¢–∏–ø:** ${type === 'premium' ? 'Telegram Premium –Ω–∞ 3 –º–µ—Å—è—Ü–∞' : '–ó–≤—ë–∑–¥—ã'}`;

        await bot.sendMessage(ADMIN_CHANNEL, adminMessage, { parse_mode: 'Markdown' });
        await bot.sendMessage(chatId, '‚úÖ –ó–∞—è–≤–∫–∞ –Ω–∞ –≤—ã–≤–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –û–∂–∏–¥–∞–π—Ç–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏.');

    } catch (error) {
        console.error('Error in withdraw command:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞—è–≤–∫–∏ –Ω–∞ –≤—ã–≤–æ–¥.');
    }
}

bot.onText(/\/withdraw15/, (msg) => handleWithdrawCommand(msg, 15));
bot.onText(/\/withdraw25/, (msg) => handleWithdrawCommand(msg, 25));
bot.onText(/\/withdraw50/, (msg) => handleWithdrawCommand(msg, 50));
bot.onText(/\/withdraw100/, (msg) => handleWithdrawCommand(msg, 100));
bot.onText(/\/withdrawpremium/, (msg) => handleWithdrawCommand(msg, 1300, 'premium'));

// Tasks command
bot.onText(/\/tasks/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        if (!user) {
            await bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
            return;
        }

        const allTasks = await db.getTasks();
        const completedTasks = await db.getUserCompletedTasks(user.id);
        const completedTaskIds = completedTasks.map(t => t.id);
        const availableTasks = allTasks.filter(task => !completedTaskIds.includes(task.id));

        if (availableTasks.length === 0) {
            await bot.sendMessage(chatId, '‚úÖ –í—Å–µ –∑–∞–¥–∞–Ω–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω—ã! –û–∂–∏–¥–∞–π—Ç–µ –Ω–æ–≤—ã—Ö –∑–∞–¥–∞–Ω–∏–π.');
            return;
        }

        let message = `üìã **–ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è**

üìä **–ü—Ä–æ–≥—Ä–µ—Å—Å:** ${completedTasks.length}/${allTasks.length} –∑–∞–¥–∞–Ω–∏–π –≤—ã–ø–æ–ª–Ω–µ–Ω–æ

üéØ **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è:**\n\n`;

        availableTasks.forEach((task, index) => {
            message += `**${index + 1}. ${task.channel_name || task.channel_id}**\n`;
            message += `üí∞ –ù–∞–≥—Ä–∞–¥–∞: ${task.reward} ‚≠ê\n`;
            message += `üì∫ –ö–∞–Ω–∞–ª: ${task.channel_id}\n`;
            message += `üîó –ö–æ–º–∞–Ω–¥–∞: /task${task.id}\n\n`;
        });

        message += `üí° **–î–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /task[ID]**\n–ù–∞–ø—Ä–∏–º–µ—Ä: /task${availableTasks[0].id}`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in tasks:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∑–∞–¥–∞–Ω–∏–π.');
    }
});

// Task execution command
bot.onText(/\/task(\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const taskId = parseInt(match[1]);
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const result = await db.executeQuery('SELECT * FROM tasks WHERE id = $1 AND is_active = TRUE', [taskId]);
        
        if (result.rows.length === 0) {
            await bot.sendMessage(chatId, '‚ùå –ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.');
            return;
        }

        const task = result.rows[0];
        
        // Check if already completed
        const completed = await db.executeQuery('SELECT 1 FROM completed_tasks WHERE user_id = $1 AND task_id = $2', [userId, taskId]);
        if (completed.rows.length > 0) {
            await bot.sendMessage(chatId, '‚ùå –≠—Ç–æ –∑–∞–¥–∞–Ω–∏–µ —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ.');
            return;
        }

        // Check subscription to task channel
        try {
            const member = await bot.getChatMember(task.channel_id, userId);
            
            if (member.status === 'left' || member.status === 'kicked') {
                const channelLink = task.channel_id.startsWith('@') ? 
                    `https://t.me/${task.channel_id.substring(1)}` : 
                    task.channel_id;

                const keyboard = {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'üì∫ –ü–µ—Ä–µ–π—Ç–∏ –∫ –∫–∞–Ω–∞–ª—É', url: channelLink }],
                            [{ text: '‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É', callback_data: `check_task_${taskId}` }]
                        ]
                    }
                };

                await bot.sendMessage(chatId, `üìã **–ó–∞–¥–∞–Ω–∏–µ: ${task.channel_name || task.channel_id}**\n\n‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª!\n\nüí∞ **–ù–∞–≥—Ä–∞–¥–∞:** ${task.reward} ‚≠ê\n\n**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:**\n1. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –∫ –∫–∞–Ω–∞–ª—É\n2. –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å\n3. –ù–∞–∂–º–∏—Ç–µ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É"`, {
                    parse_mode: 'Markdown',
                    ...keyboard
                });
                return;
            }

            // User is subscribed - complete task
            const taskCompleted = await db.completeTask(userId, taskId);
            
            if (taskCompleted) {
                await bot.sendMessage(chatId, `‚úÖ **–ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!**\n\n–í—ã –ø–æ–ª—É—á–∏–ª–∏ **${task.reward} ‚≠ê**\n\nüí∞ –ù–∞–≥—Ä–∞–¥–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –±–∞–ª–∞–Ω—Å!`, { parse_mode: 'Markdown' });
            } else {
                await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏—è.');
            }

        } catch (error) {
            // Auto-approve if bot can't check (private channel or no admin rights)
            console.log(`Auto-approving task ${taskId} for user ${userId} due to access restriction`);
            
            const taskCompleted = await db.completeTask(userId, taskId);
            
            if (taskCompleted) {
                await bot.sendMessage(chatId, `‚úÖ **–ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!**\n\n–í—ã –ø–æ–ª—É—á–∏–ª–∏ **${task.reward} ‚≠ê**\n\nüí∞ –ù–∞–≥—Ä–∞–¥–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –±–∞–ª–∞–Ω—Å!\n\n‚ö†Ô∏è *–ü–æ–¥–ø–∏—Å–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞—Å—á–∏—Ç–∞–Ω–∞*`, { parse_mode: 'Markdown' });
            } else {
                await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏—è.');
            }
        }

    } catch (error) {
        console.error('Error in task execution:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è.');
    }
});

// Instruction command
bot.onText(/\/instruction/, async (msg) => {
    const chatId = msg.chat.id;
    
    const message = `üìñ **–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –±–æ—Ç—É**

üéØ **–ö–∞–∫ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –∑–≤—ë–∑–¥—ã:**

1Ô∏è‚É£ **–ö–ª–∏–∫–µ—Ä** - –Ω–∞–∂–∏–º–∞–π—Ç–µ /clicker –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –∏ –ø–æ–ª—É—á–∞–π—Ç–µ 0.1 ‚≠ê
2Ô∏è‚É£ **–ó–∞–¥–∞–Ω–∏—è** - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /tasks –∏ –ø–æ–¥–ø–∏—Å—ã–≤–∞–π—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã –∑–∞ –Ω–∞–≥—Ä–∞–¥—ã
3Ô∏è‚É£ **–†–µ—Ñ–µ—Ä–∞–ª—ã** - /invite –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ 3 ‚≠ê –∑–∞ –∫–∞–∂–¥–æ–≥–æ
4Ô∏è‚É£ **–ö–µ–π—Å—ã** - /cases –æ—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –∫–µ–π—Å—ã —Å –ø—Ä–∏–∑–∞–º–∏ (–Ω—É–∂–Ω–æ 3+ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤ –¥–µ–Ω—å)
5Ô∏è‚É£ **–õ–æ—Ç–µ—Ä–µ—è** - /lottery —É—á–∞—Å—Ç–≤—É–π—Ç–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–∞—Ö

üí∞ **–í—ã–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤:**
‚Ä¢ –ú–∏–Ω–∏–º—É–º 5 —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –¥–ª—è –≤—ã–≤–æ–¥–∞
‚Ä¢ /withdraw - –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –≤—ã–≤–æ–¥–∞
‚Ä¢ –î–æ—Å—Ç—É–ø–Ω—ã —Å—É–º–º—ã: 15, 25, 50, 100 ‚≠ê
‚Ä¢ Telegram Premium –Ω–∞ 3 –º–µ—Å—è—Ü–∞ –∑–∞ 1300 ‚≠ê

üìà **–°–æ–≤–µ—Ç—ã:**
‚Ä¢ –ó–∞—Ö–æ–¥–∏—Ç–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥—Ä—É–∑–µ–π
‚Ä¢ –í—ã–ø–æ–ª–Ω—è–π—Ç–µ –≤—Å–µ –∑–∞–¥–∞–Ω–∏—è
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /promocode –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±–æ–Ω—É—Å–æ–≤

üéÆ **–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**
/profile /invite /clicker /withdraw /tasks /cases /lottery /ratings`;

    await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
});

// Ratings command
bot.onText(/\/ratings/, async (msg) => {
    const chatId = msg.chat.id;
    
    try {
        const allResult = await db.executeQuery(`
            SELECT first_name, referrals_count 
            FROM users 
            ORDER BY referrals_count DESC 
            LIMIT 10
        `);
        
        const weekResult = await db.executeQuery(`
            SELECT first_name, referrals_today 
            FROM users 
            WHERE updated_at > CURRENT_DATE - INTERVAL '7 days'
            ORDER BY referrals_today DESC 
            LIMIT 10
        `);
        
        let message = 'üèÜ **–†–µ–π—Ç–∏–Ω–≥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π**\n\n';
        
        message += '**üèÜ –û–±—â–∏–π —Ä–µ–π—Ç–∏–Ω–≥ –ø–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞–º:**\n';
        if (allResult.rows.length === 0) {
            message += '–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö.\n\n';
        } else {
            allResult.rows.forEach((user, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                message += `${medal} **${user.first_name}** - ${user.referrals_count} —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤\n`;
            });
            message += '\n';
        }
        
        message += '**üìÖ –†–µ–π—Ç–∏–Ω–≥ –∑–∞ –Ω–µ–¥–µ–ª—é:**\n';
        if (weekResult.rows.length === 0) {
            message += '–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö.\n';
        } else {
            weekResult.rows.forEach((user, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                message += `${medal} **${user.first_name}** - ${user.referrals_today} —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤\n`;
            });
        }

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in ratings:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ–π—Ç–∏–Ω–≥–∞.');
    }
});

// Cases command
bot.onText(/\/cases/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        if (!user) {
            await bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
            return;
        }

        const now = new Date();
        const lastCaseOpen = user.last_case_open ? new Date(user.last_case_open) : null;
        const canOpen = !lastCaseOpen || now.toDateString() !== lastCaseOpen.toDateString();
        const hasEnoughReferrals = user.referrals_today >= 3;

        if (!hasEnoughReferrals) {
            const message = `üéÅ **–ö–µ–π—ÅÔøΩÔøΩ**

‚ùå **–î–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–∞ –Ω—É–∂–Ω–æ –ø—Ä–∏–≤–µ—Å—Ç–∏ 3+ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤ –¥–µ–Ω—å**

**–í–∞—à–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—ã —Å–µ–≥–æ–¥–Ω—è:** ${user.referrals_today}/3

–ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∫–æ–º–∞–Ω–¥–æ–π /invite –∏ –≤–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å!`;

            await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
            return;
        }

        if (!canOpen) {
            const message = `üéÅ **–ö–µ–π—Å—ã**

‚è∞ **–í—ã —É–∂–µ –æ—Ç–∫—Ä—ã–ª–∏ –∫–µ–π—Å —Å–µ–≥–æ–¥–Ω—è!**

–í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –∑–∞–≤—Ç—Ä–∞ –∑–∞ –Ω–æ–≤—ã–º –∫–µ–π—Å–æ–º!`;

            await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
            return;
        }

        // Open case
        const reward = Math.floor(Math.random() * 10) + 1; // 1-10 stars
        await db.updateUserBalance(user.id, reward);
        await db.updateUserField(user.id, 'last_case_open', now);

        const message = `üéÅ **–ö–µ–π—Å—ã**

üéâ **–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!** –í—ã –æ—Ç–∫—Ä—ã–ª–∏ –∫–µ–π—Å –∏ –ø–æ–ª—É—á–∏–ª–∏ **${reward} ‚≠ê**

üí∞ **–í–∞—à –±–∞–ª–∞–Ω—Å:** ${user.balance + reward} ‚≠ê

‚è∞ –í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –∑–∞–≤—Ç—Ä–∞ –∑–∞ –Ω–æ–≤—ã–º –∫–µ–π—Å–æ–º!`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in cases:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–∞.');
    }
});

// Lottery command
bot.onText(/\/lottery/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const result = await db.executeQuery('SELECT * FROM lotteries WHERE is_active = TRUE ORDER BY id');

        if (result.rows.length === 0) {
            await bot.sendMessage(chatId, 'üé∞ –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ—Ç–µ—Ä–µ–π.');
            return;
        }

        // Get user's tickets
        const ticketsResult = await db.executeQuery(
            'SELECT lottery_id FROM lottery_tickets WHERE user_id = $1',
            [userId]
        );
        const userTickets = ticketsResult.rows.map(row => row.lottery_id);

        let message = 'üé∞ **–ê–∫—Ç–∏–≤–Ω—ã–µ –ª–æ—Ç–µ—Ä–µ–∏**\n\n';
        const keyboards = [];

        result.rows.forEach((lottery, index) => {
            const hasPurchased = userTickets.includes(lottery.id);

            message += `**${lottery.name}**\n`;
            message += `üí∞ –¶–µ–Ω–∞ –±–∏–ª–µ—Ç–∞: ${lottery.ticket_price} ‚≠ê\n`;
            message += `üé´ –ë–∏–ª–µ—Ç–æ–≤: ${lottery.current_tickets}/${lottery.max_tickets}\n`;
            message += `üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: ${lottery.winners_count}\n`;

            if (hasPurchased) {
                message += `‚úÖ **–í–∞—à –±–∏–ª–µ—Ç –∫—É–ø–ª–µ–Ω!**\n`;
            } else {
                if (lottery.current_tickets >= lottery.max_tickets) {
                    message += `üö´ **–ü–†–û–î–ê–ù–û**\n`;
                } else {
                    message += `üîó –ö–æ–º–∞–Ω–¥–∞: /buy${lottery.id}\n`;
                    keyboards.push([{ text: `üé´ –ö—É–ø–∏—Ç—å –±–∏–ª–µ—Ç - ${lottery.name}`, callback_data: `lottery_buy_${lottery.id}` }]);
                }
            }
            message += '\n';
        });

        message += 'üí° **–î–ª—è –ø–æ–∫—É–ø–∫–∏ –±–∏–ª–µ—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /buy[ID]**\n–ù–∞–ø—Ä–∏–º–µ—Ä: /buy1';

        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: { inline_keyboard: keyboards }
        });

    } catch (error) {
        console.error('Error in lottery:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–æ—Ç–µ—Ä–µ–π.');
    }
});

// Buy lottery ticket command
bot.onText(/\/buy(\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const lotteryId = parseInt(match[1]);
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    try {
        const user = await db.getUser(userId);
        
        // Get lottery details
        const lotteryResult = await db.executeQuery('SELECT * FROM lotteries WHERE id = $1 AND is_active = TRUE', [lotteryId]);
        
        if (lotteryResult.rows.length === 0) {
            await bot.sendMessage(chatId, '‚ùå –õ–æ—Ç–µ—Ä–µ—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.');
            return;
        }

        const lottery = lotteryResult.rows[0];

        // Check if user already has a ticket
        const ticketCheck = await db.executeQuery(
            'SELECT 1 FROM lottery_tickets WHERE lottery_id = $1 AND user_id = $2',
            [lotteryId, userId]
        );

        if (ticketCheck.rows.length > 0) {
            await bot.sendMessage(chatId, '‚ùå –í—ã —ÉÔøΩÔøΩ–µ –∫—É–ø–∏–ª–∏ –±–∏–ª–µ—Ç –≤ —ç—Ç—É –ª–æ—Ç–µ—Ä–µ—é!');
            return;
        }

        // Check balance
        if (user.balance < lottery.ticket_price) {
            await bot.sendMessage(chatId, '‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –±–∏–ª–µ—Ç–∞!');
            return;
        }

        // Check if lottery is full
        if (lottery.current_tickets >= lottery.max_tickets) {
            await bot.sendMessage(chatId, '‚ùå –í—Å–µ –±–∏–ª–µ—Ç—ã –≤ –ª–æ—Ç–µ—Ä–µ—é –ø—Ä–æ–¥–∞–Ω—ã!');
            return;
        }

        // Buy ticket
        await db.executeQuery('BEGIN');
        
        try {
            // Add ticket
            await db.executeQuery(
                'INSERT INTO lottery_tickets (lottery_id, user_id) VALUES ($1, $2)',
                [lotteryId, userId]
            );

            // Update lottery count
            const updatedLottery = await db.executeQuery(
                'UPDATE lotteries SET current_tickets = current_tickets + 1 WHERE id = $1 RETURNING current_tickets, max_tickets',
                [lotteryId]
            );

            // Deduct from balance
            await db.updateUserBalance(userId, -lottery.ticket_price);

            await db.executeQuery('COMMIT');

            // Check if lottery is now full and distribute rewards
            const newTicketCount = updatedLottery.rows[0].current_tickets;
            const maxTickets = updatedLottery.rows[0].max_tickets;

            if (newTicketCount >= maxTickets) {
                console.log(`[LOTTERY] Lottery ${lotteryId} is full, distributing rewards...`);
                await distributeLotteryRewards(lotteryId, lottery);
            }

            await bot.sendMessage(chatId, `‚úÖ –ë–∏–ª–µ—Ç —É—Å–ø–µ—à–Ω–æ –∫—É–ø–ª–µ–Ω –∑–∞ ${lottery.ticket_price} ‚≠ê!`);

        } catch (error) {
            await db.executeQuery('ROLLBACK');
            throw error;
        }

    } catch (error) {
        console.error('Error in lottery buy:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–∫—É–ø–∫–∏ –±–∏–ª–µ—Ç–∞.');
    }
});

// Promocode command
bot.onText(/\/promocode/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check subscription first
    const isSubscribed = await checkAllSubscriptions(userId);
    if (!isSubscribed) {
        const subData = await getSubscriptionMessage();
        await bot.sendMessage(chatId, subData.message, {
            reply_markup: { inline_keyboard: subData.buttons }
        });
        return;
    }
    
    // Set temp action for user
    await db.updateUserField(userId, 'temp_action', 'awaiting_promocode');
    
    await bot.sendMessage(chatId, 'üéÅ –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥:');
});

// Admin commands
bot.onText(/\/admin/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–Ω–µ–ª–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.');
        return;
    }

    try {
        const stats = await db.getUserStats();

        const message = `üîß **–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å**

üìä **–ë—ã—Å—Ç—Ä–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${stats.total_users}
üí∞ –û–±—â–∏–π –±–∞–ª–∞–Ω—Å: ${stats.total_balance} ‚≠ê

**–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**
üìä **/adminstats** - –ø–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
üé∞ **/endlottery [ID]** - –∑–∞–≤–µ—Ä—à–∏—Ç—å –ª–æ—Ç–µ—Ä–µ—é –≤—Ä—É—á–Ω—É—é
üë• **/refupplayer [ID] [—á–∏—Å–ª–æ]** - –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
‚≠ê **/starsupplayer [ID] [—á–∏—Å–ª–æ]** - –¥–æ–±–∞–≤–∏—Ç—å –∑–≤—ë–∑–¥—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é

**–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º:**
üìã /create_task —Ç–∏–ø|–∫–∞–Ω–∞–ª|–Ω–∞–≥—Ä–∞–¥–∞|–ª–∏–º–∏—Ç
üì∫ /add_channel –∫–∞–Ω–∞–ª|–Ω–∞–∑–≤–∞–Ω–∏–µ  
üé∞ /create_lottery –Ω–∞–∑–≤–∞–Ω–∏–µ|–±–∏–ª–µ—Ç—ã|—Ü–µ–Ω–∞|–ø–æ–±–µ–¥–∏—Ç–µ–ª–∏|–ø—Ä–æ—Ü–µ–Ω—Ç
üéÅ /create_promo –ö–û–î|–Ω–∞–≥—Ä–∞–¥–∞|–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

**–£–¥–∞–ª–µ–Ω–∏–µ:**
‚ùå /delete_task [ID] /delete_channel [ID] /delete_lottery [ID] /delete_promo [ID]`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in admin command:', error);
        bot.sendMessage(chatId, '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∞–¥–º–∏–Ω –ø–∞–Ω–µ–ª–∏.');
    }
});

// Admin stats command
bot.onText(/\/adminstats/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const stats = await db.getUserStats();
        
        const weeklyResult = await db.executeQuery(`
            SELECT COUNT(*) as weekly_active 
            FROM users 
            WHERE updated_at > CURRENT_DATE - INTERVAL '7 days'
        `);
        
        const dailyResult = await db.executeQuery(`
            SELECT COUNT(*) as daily_active 
            FROM users 
            WHERE updated_at > CURRENT_DATE
        `);

        const message = `üìä **–î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞**

üë• **–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:** ${stats.total_users}
üìÖ **–ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞ –Ω–µ–¥–µ–ª—é:** ${weeklyResult.rows[0]?.weekly_active || 0}
üìÖ **–ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞ –¥–µ–Ω—å:** ${dailyResult.rows[0]?.daily_active || 0}
üí∞ **–û–±—â–∏–π –±–∞–ª–∞–Ω—Å:** ${stats.total_balance} ‚≠ê
üë• **–í—Å–µ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤:** ${stats.total_referrals}`;

        await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error('Error in admin stats:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.');
    }
});

// End lottery command
bot.onText(/\/endlottery (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const lotteryId = parseInt(match[1]);
        
        // Get lottery details
        const lotteryResult = await db.executeQuery('SELECT * FROM lotteries WHERE id = $1 AND is_active = TRUE', [lotteryId]);
        
        if (lotteryResult.rows.length === 0) {
            bot.sendMessage(chatId, `‚ùå –ê–∫—Ç–∏–≤–Ω–∞—è –ª–æ—Ç–µ—Ä–µ—è —Å ID ${lotteryId} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.`);
            return;
        }

        const lottery = lotteryResult.rows[0];
        
        // Check if there are participants
        const participantsResult = await db.executeQuery('SELECT COUNT(*) as count FROM lottery_tickets WHERE lottery_id = $1', [lotteryId]);
        const participantCount = participantsResult.rows[0].count;
        
        if (participantCount === 0) {
            bot.sendMessage(chatId, `‚ùå –í –ª–æ—Ç–µ—Ä–µ–µ ${lottery.name} –Ω–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤!`);
            return;
        }

        // Distribute rewards
        await distributeLotteryRewards(lotteryId, lottery);
        
        bot.sendMessage(chatId, `‚úÖ –õ–æ—Ç–µ—Ä–µ—è "${lottery.name}" –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\nüë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: ${participantCount}\nüèÜ –ù–∞–≥—Ä–∞–¥—ã —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –º–µ–∂–¥—É ${Math.min(lottery.winners_count, participantCount)} –ø–æ–±–µ–¥–∏—Ç–µ–ª—è–º–∏.`);

    } catch (error) {
        console.error('Error ending lottery:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ª–æ—Ç–µ—Ä–µ–∏.');
    }
});

// Ref up player command
bot.onText(/\/refupplayer (\d+) (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const targetUserId = parseInt(match[1]);
        const refCount = parseInt(match[2]);
        
        const result = await db.executeQuery(
            'UPDATE users SET referrals_count = referrals_count + $1, referrals_today = referrals_today + $2 WHERE id = $3',
            [refCount, refCount, targetUserId]
        );

        if (result.rowCount > 0) {
            bot.sendMessage(chatId, `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${targetUserId} –¥–æ–±–∞–≤–ª–µ–Ω–æ ${refCount} —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤!`);
            
            // Notify user
            try {
                await bot.sendMessage(targetUserId, `üéâ **–ë–æ–Ω—É—Å –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏!**\n\n–í–∞–º –¥–æ–±–∞–≤–ª–µ–Ω–æ **${refCount} —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤** –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏!\n\nüí´ –°–ø–∞—Å–∏–±–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å!`, { parse_mode: 'Markdown' });
            } catch (error) {
                console.log('Could not notify user about referral bonus');
            }
        } else {
            bot.sendMessage(chatId, `‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID ${targetUserId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
        }
    } catch (error) {
        console.error('Error in refupplayer:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤.');
    }
});

// Stars up player command
bot.onText(/\/starsupplayer (\d+) (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const targetUserId = parseInt(match[1]);
        const starsCount = parseInt(match[2]);
        
        const result = await db.updateUserBalance(targetUserId, starsCount);

        if (result) {
            bot.sendMessage(chatId, `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${targetUserId} –¥–æ–±–∞–≤–ª–µ–Ω–æ ${starsCount} ‚≠ê!`);
            
            // Notify user
            try {
                await bot.sendMessage(targetUserId, `üéâ **–ë–æ–Ω—É—Å –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏!**\n\n–í–∞–º –¥–æ–±–∞–≤–ª–µ–Ω–æ **${starsCount} ‚≠ê** –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏!\n\nüí´ –°–ø–∞—Å–∏–±–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å!`, { parse_mode: 'Markdown' });
            } catch (error) {
                console.log('Could not notify user about stars bonus');
            }
        } else {
            bot.sendMessage(chatId, `‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID ${targetUserId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
        }
    } catch (error) {
        console.error('Error in starsupplayer:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–≤—ë–∑–¥.');
    }
});

// Test command to verify version
bot.onText(/\/test_version/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    const testMessage = `üîß **–¢–µ—Å—Ç –≤–µ—Ä—Å–∏–∏ –±–æ—Ç–∞**

üìÖ –í–µ—Ä—Å–∏—è: –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø v4.0 - –ë–ï–ó INLINE –ö–ù–û–ü–û–ö!
üïí –í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU')}
üë§ –í–∞—à ID: ${userId}
üîß Admin ID: ${isAdmin(userId) ? '–í–´ –ê–î–ú–ò–ù' : '–ù–ï –ê–î–ú–ò–ù'}

‚úÖ –ï—Å–ª–∏ –≤—ã –≤–∏–¥–∏—Ç–µ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ - —Ä–∞–±–æ—Ç–∞–µ—Ç –ù–û–í–ê–Ø –≤–µ—Ä—Å–∏—è!
üéØ –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã –Ω–∞ –∫–æ–º–∞–Ω–¥—ã!`;

    bot.sendMessage(chatId, testMessage, { parse_mode: 'Markdown' });
});

// Admin task creation
bot.onText(/\/create_task (.+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const params = match[1].split('|');
        if (params.length !== 4) {
            bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /create_task —Ç–∏–ø|–Ω–∞–∑–≤–∞–Ω–∏–µ|–Ω–∞–≥—Ä–∞–¥–∞|–ª–∏–º–∏—Ç');
            return;
        }

        const [type, channelId, reward, limit] = params;

        await db.executeQuery(
            'INSERT INTO tasks (channel_id, channel_name, reward) VALUES ($1, $2, $3)',
            [channelId.trim(), `${type} ${channelId}`.trim(), parseFloat(reward)]
        );

        bot.sendMessage(chatId, `‚úÖ –ó–∞–¥–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ!\nüì∫ –ö–∞–Ω–∞–ª: ${channelId}\nüí∞ –ù–∞–≥—Ä–∞–¥–∞: ${reward} ‚≠ê`);

    } catch (error) {
        console.error('Error creating task:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è.');
    }
});

// Admin channel management
bot.onText(/\/add_channel (.+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const params = match[1].split('|');
        const channelId = params[0].trim();
        const channelName = params[1] ? params[1].trim() : channelId;

        await db.executeQuery(
            'INSERT INTO required_channels (channel_id, channel_name) VALUES ($1, $2) ON CONFLICT (channel_id) DO NOTHING',
            [channelId, channelName]
        );

        bot.sendMessage(chatId, `‚úÖ –ö–∞–Ω–∞–ª –¥–æ–±–∞–≤–ª–µ–Ω!\nüì∫ ${channelName} (${channelId})`);

    } catch (error) {
        console.error('Error adding channel:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞.');
    }
});

// Admin lottery creation
bot.onText(/\/create_lottery (.+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const params = match[1].split('|');
        if (params.length !== 5) {
            bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /create_lottery –Ω–∞–∑–≤–∞–Ω–∏–µ|–±–∏–ª–µ—Ç—ã|—Ü–µ–Ω–∞|–ø–æ–±–µ–¥–∏—Ç–µ–ª–∏|–ø—Ä–æ—Ü–µ–Ω—Ç');
            return;
        }

        const [name, maxTickets, ticketPrice, winnersCount, botPercent] = params;

        await db.executeQuery(
            'INSERT INTO lotteries (name, ticket_price, max_tickets, winners_count) VALUES ($1, $2, $3, $4)',
            [name.trim(), parseFloat(ticketPrice), parseInt(maxTickets), parseInt(winnersCount)]
        );

        bot.sendMessage(chatId, `‚úÖ –õ–æ—Ç–µ—Ä–µ—è —Å–æ–∑–¥–∞–Ω–∞!\nüé∞ ${name}\nüé´ ${maxTickets} –±–∏–ª–µ—Ç–æ–≤ –ø–æ ${ticketPrice} ‚≠ê\nüèÜ ${winnersCount} –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π`);

    } catch (error) {
        console.error('Error creating lottery:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ—Ç–µ—Ä–µ–∏.');
    }
});

// Admin promocode creation
bot.onText(/\/create_promo (.+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const params = match[1].split('|');
        if (params.length !== 3) {
            bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /create_promo –ö–û–î|–Ω–∞–≥—Ä–∞–¥–∞|–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è');
            return;
        }

        const [code, reward, maxUses] = params;

        await db.executeQuery(
            'INSERT INTO promocodes (code, reward, max_uses, created_by) VALUES ($1, $2, $3, $4)',
            [code.trim().toUpperCase(), parseFloat(reward), parseInt(maxUses), userId]
        );

        bot.sendMessage(chatId, `‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ —Å–æ–∑–¥–∞–Ω!\nüéÅ –ö–æ–¥: ${code.toUpperCase()}\nüí∞ –ù–∞–≥—Ä–∞–¥–∞: ${reward} ‚≠ê\nüìä –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π: ${maxUses}`);

    } catch (error) {
        console.error('Error creating promocode:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞ (–≤–æ–∑–º–æ–∂–Ω–æ, –∫–æ–¥ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç).');
    }
});

// Callback query handler (for subscription check and task check)
bot.on('callback_query', async (callbackQuery) => {
    const msg = callbackQuery.message;
    const chatId = msg.chat.id;
    const userId = callbackQuery.from.id;
    const data = callbackQuery.data;

    try {
        if (data === 'check_subscriptions') {
            const isSubscribed = await checkAllSubscriptions(userId);
            
            if (isSubscribed) {
                await db.updateUserField(userId, 'is_subscribed', true);
                
                // Process pending referral if exists
                const user = await db.getUser(userId);
                if (user && user.pending_referrer) {
                    const invitedBy = user.pending_referrer;
                    
                    // Update referrer stats
                    await db.executeQuery(
                        'UPDATE users SET referrals_count = referrals_count + 1, referrals_today = referrals_today + 1, balance = balance + 3 WHERE id = $1',
                        [invitedBy]
                    );
                    
                    // Clear pending referrer
                    await db.updateUserField(userId, 'pending_referrer', null);
                    await db.updateUserField(userId, 'invited_by', invitedBy);

                    // Send notification to referrer
                    try {
                        const userInfo = await db.getUser(userId);
                        const message = `üéâ **–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!**

üë§ –ü–æ –≤–∞—à–µ–π —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: **${userInfo.first_name}**

üí∞ **–í—ã –ø–æ–ª—É—á–∏–ª–∏:** +3 ‚≠ê
üíé **–í–∞—à –±–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω!**

üë• –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –¥—Ä—É–∑–µ–π –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –µ—â–µ –±–æ–ª—å—à–µ –∑–≤—ë–∑–¥!`;

                        await bot.sendMessage(invitedBy, message, { parse_mode: 'Markdown' });
                    } catch (error) {
                        console.error('Error sending referral notification:', error);
                    }
                }
                
                await bot.editMessageText(`‚úÖ **–û—Ç–ª–∏—á–Ω–æ! –í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!**\n\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞.\n\n${getMainMenuText()}`, {
                    chat_id: chatId,
                    message_id: msg.message_id,
                    parse_mode: 'Markdown'
                });
            } else {
                await bot.answerCallbackQuery(callbackQuery.id, {
                    text: '‚ùå ÔøΩÔøΩ—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–µ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!',
                    show_alert: true
                });
            }
        } else if (data.startsWith('check_task_')) {
            const taskId = data.replace('check_task_', '');
            
            const result = await db.executeQuery('SELECT * FROM tasks WHERE id = $1 AND is_active = TRUE', [taskId]);
            
            if (result.rows.length === 0) {
                await bot.editMessageText('‚ùå –ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.', {
                    chat_id: chatId,
                    message_id: msg.message_id
                });
                return;
            }

            const task = result.rows[0];

            try {
                const member = await bot.getChatMember(task.channel_id, userId);
                
                if (member.status === 'left' || member.status === 'kicked') {
                    await bot.answerCallbackQuery(callbackQuery.id, {
                        text: '‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª!',
                        show_alert: true
                    });
                    return;
                }

                // Complete the task
                const taskCompleted = await db.completeTask(userId, taskId);
                
                if (taskCompleted) {
                    await bot.editMessageText(`‚úÖ **–ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!**\n\n–í—ã –ø–æ–ª—É—á–∏–ª–∏ **${task.reward} ‚≠ê**\n\nüí∞ –ù–∞–≥—Ä–∞–¥–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –±–∞–ª–∞–Ω—Å!`, {
                        chat_id: chatId,
                        message_id: msg.message_id,
                        parse_mode: 'Markdown'
                    });
                } else {
                    await bot.editMessageText('‚ùå –ó–∞–¥–∞–Ω–∏–µ —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Ä–∞–Ω–µ–µ.', {
                        chat_id: chatId,
                        message_id: msg.message_id
                    });
                }

            } catch (error) {
                // Auto-approve if bot can't check
                console.log(`Auto-approving task ${taskId} for user ${userId} due to access restriction`);
                
                const taskCompleted = await db.completeTask(userId, taskId);
                
                if (taskCompleted) {
                    await bot.editMessageText(`‚úÖ **–ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!**\n\n–í—ã –ø–æ–ª—É—á–∏–ª–∏ **${task.reward} ‚≠ê**\n\nüí∞ –ù–∞–≥—Ä–∞–¥–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –±–∞–ª–∞–Ω—Å!\n\n‚ö†Ô∏è *–ü–æ–¥–ø–∏—Å–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞—Å—á–∏—Ç–∞–Ω–∞*`, {
                        chat_id: chatId,
                        message_id: msg.message_id,
                        parse_mode: 'Markdown'
                    });
                } else {
                    await bot.editMessageText('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏—è.', {
                        chat_id: chatId,
                        message_id: msg.message_id
                    });
                }
            }
        } else if (data.startsWith('lottery_buy_')) {
            const lotteryId = data.replace('lottery_buy_', '');
            await handleLotteryBuy(chatId, msg.message_id, userId, lotteryId);
        }

        await bot.answerCallbackQuery(callbackQuery.id);

    } catch (error) {
        console.error('Error handling callback query:', error);
        await bot.answerCallbackQuery(callbackQuery.id, {
            text: '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
            show_alert: true
        });
    }
});

// Handle lottery buy (kept for backward compatibility)
async function handleLotteryBuy(chatId, messageId, userId, lotteryId) {
    try {
        const user = await db.getUser(userId);
        
        const lotteryResult = await db.executeQuery('SELECT * FROM lotteries WHERE id = $1 AND is_active = TRUE', [lotteryId]);
        
        if (lotteryResult.rows.length === 0) {
            await bot.editMessageText('‚ùå –õ–æ—Ç–µ—Ä–µ—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.', {
                chat_id: chatId,
                message_id: messageId
            });
            return;
        }

        const lottery = lotteryResult.rows[0];

        const ticketCheck = await db.executeQuery(
            'SELECT 1 FROM lottery_tickets WHERE lottery_id = $1 AND user_id = $2',
            [lotteryId, userId]
        );

        if (ticketCheck.rows.length > 0) {
            await bot.editMessageText('‚ùå –í—ã —É–∂–µ –∫—É–ø–∏–ª–∏ –±–∏–ª–µ—Ç –≤ —ç—Ç—É –ª–æ—Ç–µ—Ä–µ—é!', {
                chat_id: chatId,
                message_id: messageId
            });
            return;
        }

        if (user.balance < lottery.ticket_price) {
            await bot.editMessageText('‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –±–∏–ª–µ—Ç–∞!', {
                chat_id: chatId,
                message_id: messageId
            });
            return;
        }

        if (lottery.current_tickets >= lottery.max_tickets) {
            await bot.editMessageText('‚ùå –í—Å–µ –±–∏–ª–µ—Ç—ã –≤ –ª–æ—Ç–µ—Ä–µ—é –ø—Ä–æ–¥–∞–Ω—ã!', {
                chat_id: chatId,
                message_id: messageId
            });
            return;
        }

        await db.executeQuery('BEGIN');
        
        try {
            await db.executeQuery(
                'INSERT INTO lottery_tickets (lottery_id, user_id) VALUES ($1, $2)',
                [lotteryId, userId]
            );

            const updatedLottery = await db.executeQuery(
                'UPDATE lotteries SET current_tickets = current_tickets + 1 WHERE id = $1 RETURNING current_tickets, max_tickets',
                [lotteryId]
            );

            await db.updateUserBalance(userId, -lottery.ticket_price);
            await db.executeQuery('COMMIT');

            const newTicketCount = updatedLottery.rows[0].current_tickets;
            const maxTickets = updatedLottery.rows[0].max_tickets;

            if (newTicketCount >= maxTickets) {
                console.log(`[LOTTERY] Lottery ${lotteryId} is full, distributing rewards...`);
                await distributeLotteryRewards(lotteryId, lottery);
            }

            await bot.editMessageText(`‚úÖ –ë–∏–ª–µ—Ç —É—Å–ø–µ—à–Ω–æ –∫—É–ø–ª–µ–Ω –∑–∞ ${lottery.ticket_price} ‚≠ê!`, {
                chat_id: chatId,
                message_id: messageId
            });

        } catch (error) {
            await db.executeQuery('ROLLBACK');
            throw error;
        }

    } catch (error) {
        console.error('Error in lottery buy:', error);
        await bot.editMessageText('‚ùå –û—à–∏–±–∫–∞ –ø–æ–∫—É–ø–∫–∏ –±–∏–ª–µ—Ç–∞.', {
            chat_id: chatId,
            message_id: messageId
        });
    }
}

// Lottery reward distribution
async function distributeLotteryRewards(lotteryId, lottery) {
    try {
        console.log(`[LOTTERY] Starting reward distribution for lottery ${lotteryId}`);

        const participants = await db.executeQuery(
            'SELECT user_id FROM lottery_tickets WHERE lottery_id = $1',
            [lotteryId]
        );

        if (participants.rows.length === 0) {
            console.log('[LOTTERY] No participants found');
            return;
        }

        const winnersCount = Math.min(lottery.winners_count, participants.rows.length);
        const shuffled = [...participants.rows].sort(() => 0.5 - Math.random());
        const winners = shuffled.slice(0, winnersCount);

        const totalPrizePool = lottery.ticket_price * lottery.max_tickets;
        const rewardPerWinner = Math.floor(totalPrizePool / winnersCount * 100) / 100;

        console.log(`[LOTTERY] Prize pool: ${totalPrizePool} ‚≠ê, ${winnersCount} winners, ${rewardPerWinner} ‚≠ê each`);

        for (const winner of winners) {
            await db.updateUserBalance(winner.user_id, rewardPerWinner);

            try {
                const message = `üéâ **–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ –ª–æ—Ç–µ—Ä–µ–µ!**

üé∞ –õ–æ—Ç–µ—Ä–µ—è: **${lottery.name}**
üí∞ –í–∞—à –≤—ã–∏–≥—Ä—ã—à: **${rewardPerWinner} ‚≠ê**
üèÜ –í—Å–µ–≥–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: ${winnersCount}

‚ú® –ù–∞–≥—Ä–∞–¥–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å!`;

                await bot.sendMessage(winner.user_id, message, { parse_mode: 'Markdown' });
                console.log(`[LOTTERY] Winner ${winner.user_id} notified`);
            } catch (notifyError) {
                console.error(`[LOTTERY] Failed to notify winner ${winner.user_id}:`, notifyError);
            }
        }

        await db.executeQuery(
            'UPDATE lotteries SET is_active = FALSE WHERE id = $1',
            [lotteryId]
        );

        console.log(`[LOTTERY] Lottery ${lotteryId} completed successfully`);

    } catch (error) {
        console.error('[LOTTERY] Error distributing rewards:', error);
    }
}

// Handle text messages (for promocodes)
bot.on('message', async (msg) => {
    if (msg.text && !msg.text.startsWith('/')) {
        const userId = msg.from.id;
        const chatId = msg.chat.id;
        
        try {
            const user = await db.getUser(userId);
            
            if (user && user.temp_action === 'awaiting_promocode') {
                const promocode = msg.text.trim().toUpperCase();
                
                // Clear temp action
                await db.updateUserField(userId, 'temp_action', null);
                
                // Check promocode
                const promoResult = await db.getPromocode(promocode);
                
                if (!promoResult) {
                    bot.sendMessage(chatId, '‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω!');
                    return;
                }

                // Use promocode
                const success = await db.usePromocode(userId, promoResult.id);
                
                if (success) {
                    bot.sendMessage(chatId, `‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –í—ã –ø–æ–ª—É—á–∏–ª–∏ ${promoResult.reward} ‚≠ê`);
                } else {
                    bot.sendMessage(chatId, '‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω!');
                }
            }
        } catch (error) {
            console.error('Error handling message:', error);
        }
    }
});

// Admin delete commands
bot.onText(/\/delete_task (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const taskId = parseInt(match[1]);
        const result = await db.executeQuery('DELETE FROM tasks WHERE id = $1', [taskId]);

        if (result.rowCount > 0) {
            bot.sendMessage(chatId, `‚úÖ –ó–∞–¥–∞–Ω–∏–µ —Å ID ${taskId} —É–¥–∞–ª–µ–Ω–æ!`);
        } else {
            bot.sendMessage(chatId, `‚ùå –ó–∞–¥–∞–Ω–∏–µ —Å ID ${taskId} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`);
        }
    } catch (error) {
        console.error('Error deleting task:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è.');
    }
});

bot.onText(/\/delete_channel (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const channelId = parseInt(match[1]);
        const result = await db.executeQuery('DELETE FROM required_channels WHERE id = $1', [channelId]);

        if (result.rowCount > 0) {
            bot.sendMessage(chatId, `‚úÖ –ö–∞–Ω–∞–ª —Å ID ${channelId} —É–¥–∞–ª–µ–Ω!`);
        } else {
            bot.sendMessage(chatId, `‚ùå –ö–∞–Ω–∞–ª —Å ID ${channelId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
        }
    } catch (error) {
        console.error('Error deleting channel:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —É–¥–∞ÔøΩÔøΩ–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞.');
    }
});

bot.onText(/\/delete_lottery (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const lotteryId = parseInt(match[1]);

        const ticketsResult = await db.executeQuery('SELECT COUNT(*) as count FROM lottery_tickets WHERE lottery_id = $1', [lotteryId]);
        const hasTickets = ticketsResult.rows[0].count > 0;

        if (hasTickets) {
            bot.sendMessage(chatId, `‚ùå –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ª–æ—Ç–µ—Ä–µ—é —Å ID ${lotteryId} - –≤ –Ω–µ–π –µ—Å—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∏! –°–Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ—Ä—à–∏—Ç–µ –ª–æ—Ç–µ—Ä–µ—é –∫–æ–º–∞–Ω–¥–æ–π /endlottery ${lotteryId}`);
            return;
        }

        const result = await db.executeQuery('DELETE FROM lotteries WHERE id = $1', [lotteryId]);

        if (result.rowCount > 0) {
            bot.sendMessage(chatId, `‚úÖ –õ–æ—Ç–µ—Ä–µ—è —Å ID ${lotteryId} —É–¥–∞–ª–µ–Ω–∞!`);
        } else {
            bot.sendMessage(chatId, `‚ùå –õ–æ—Ç–µ—Ä–µ—è —Å ID ${lotteryId} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.`);
        }
    } catch (error) {
        console.error('Error deleting lottery:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–ΩÔøΩÔøΩ—è –ª–æ—Ç–µ—Ä–µ–∏.');
    }
});

bot.onText(/\/delete_promo (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    if (!isAdmin(userId)) {
        bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞.');
        return;
    }

    try {
        const promoId = parseInt(match[1]);
        const result = await db.executeQuery('DELETE FROM promocodes WHERE id = $1', [promoId]);

        if (result.rowCount > 0) {
            bot.sendMessage(chatId, `‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ —Å ID ${promoId} —É–¥–∞–ª–µ–Ω!`);
        } else {
            bot.sendMessage(chatId, `‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ —Å ID ${promoId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
        }
    } catch (error) {
        console.error('Error deleting promocode:', error);
        bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞.');
    }
});

// Daily reset cron job
cron.schedule('0 0 * * *', async () => {
    console.log('üîÑ Running daily reset...');
    try {
        await db.resetDailyData();
    } catch (error) {
        console.error('Error in daily reset:', error);
    }
});

// Error handling with 409 conflict management
bot.on('polling_error', (error) => {
    if (error.code === 'ETELEGRAM' && error.response?.body?.error_code === 409) {
        console.log('‚ö†Ô∏è 409 Conflict detected - another bot instance is running');
        console.log('üîÑ This is normal when deploying updates');

        setTimeout(async () => {
            try {
                await bot.deleteWebHook();
                console.log('üßπ Webhook cleared due to 409 conflict');
            } catch (e) {
                console.log('‚ÑπÔ∏è Webhook clear attempt (may fail, that\'s ok)');
            }
        }, 5000);
    } else {
        console.error('Polling error:', error.message);
    }
});

process.on('SIGINT', async () => {
    console.log('üõë Shutting down bot...');
    await db.closeConnection();
    process.exit(0);
});

process.on('SIGTERM', async () => {
    console.log('üõë Shutting down bot...');
    await db.closeConnection();
    process.exit(0);
});

// Start the bot
startBot();
