/**
 * –£–º–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ SubGram –∫–∞–Ω–∞–ª–æ–≤
 * –†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –±–æ—Ç–∞ –∫–æ–≥–¥–∞ –Ω–µ—Ç —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏—Ö –∫–∞–Ω–∞–ª–æ–≤
 */

const db = require('./database');
const { subgramAPI } = require('./subgram-api');

/**
 * –°–æ—Å—Ç–æ—è–Ω–∏—è SubGram –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
const SUBGRAM_STATES = {
    NO_CHANNELS: 'no_channels',           // SubGram –Ω–µ –≤–µ—Ä–Ω—É–ª –∫–∞–Ω–∞–ª—ã (–Ω–æ—Ä–º–∞)
    HAS_CHANNELS: 'has_channels',         // –ï—Å—Ç—å –∫–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏
    ALL_SUBSCRIBED: 'all_subscribed',     // –ü–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã
    API_ERROR: 'api_error',               // –û—à–∏–±–∫–∞ API
    DISABLED: 'disabled'                  // SubGram –æ—Ç–∫–ª—é—á–µ–Ω
};

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ SubGram –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @param {number} userId - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Object} –°–æ—Å—Ç–æ—è–Ω–∏–µ SubGram
 */
async function getSubGramState(userId) {
    try {
        console.log(`[SMART-SUBGRAM] Checking SubGram state for user ${userId}`);

        // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SubGram
        const settings = await db.getSubGramSettings();
        if (!settings || !settings.enabled) {
            console.log('[SMART-SUBGRAM] SubGram disabled in settings');
            return {
                state: SUBGRAM_STATES.DISABLED,
                shouldBlock: false,
                channels: [],
                message: 'SubGram –æ—Ç–∫–ª—é—á–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö'
            };
        }

        // 2. –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ SubGram API
        const apiResponse = await subgramAPI.requestSponsors({
            userId: userId.toString(),
            chatId: userId.toString(),
            maxOP: settings.max_sponsors || 3,
            action: settings.default_action || 'subscribe',
            excludeChannelIds: [],
            withToken: true
        });

        // –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
        await db.logSubGramAPIRequest(
            userId,
            'smart_state_check',
            { action: 'subscribe', smart: true },
            apiResponse.data || {},
            apiResponse.success,
            apiResponse.error
        );

        // 3. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
        if (!apiResponse.success) {
            console.log(`[SMART-SUBGRAM] API error: ${apiResponse.error}`);
            return {
                state: SUBGRAM_STATES.API_ERROR,
                shouldBlock: false, // –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–∏ –æ—à–∏–±–∫–µ API
                channels: [],
                message: '–û—à–∏–±–∫–∞ SubGram API - –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω',
                error: apiResponse.error
            };
        }

        const processedData = subgramAPI.processAPIResponse(apiResponse.data);
        console.log(`[SMART-SUBGRAM] API response: status=${processedData.status}, code=${processedData.code}, channels=${processedData.channels.length}, toSubscribe=${processedData.channelsToSubscribe?.length || 0}`);
        console.log(`[SMART-SUBGRAM] Processed data:`, JSON.stringify({
            status: processedData.status,
            code: processedData.code,
            needsSubscription: processedData.needsSubscription,
            allSubscribed: processedData.allSubscribed,
            channelsCount: processedData.channels.length,
            toSubscribeCount: processedData.channelsToSubscribe?.length || 0
        }, null, 2));

        // 4. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç–≤–µ—Ç–∞

        // –£–õ–£–ß–®–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: –ø—Ä–æ–≤–µ—Ä—è–µ–º needsSubscription –≤–º–µ—Å—Ç–æ status
        if (processedData.needsSubscription && (processedData.channelsToSubscribe && processedData.channelsToSubscribe.length > 0)) {
            // –ï—Å—Ç—å –∫–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ - –ë–õ–û–ö–ò–†–£–ï–ú –¥–æ—Å—Ç—É–ø
            console.log(`[SMART-SUBGRAM] Found ${processedData.channelsToSubscribe.length} channels requiring subscription (needsSubscription: true)`);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–Ω–∞–ª—ã –≤ –ë–î
            await db.executeQuery('DELETE FROM subgram_channels WHERE user_id = $1', [userId]);
            await db.saveSubGramChannels(userId, processedData.channelsToSubscribe);

            return {
                state: SUBGRAM_STATES.HAS_CHANNELS,
                shouldBlock: true, // –ë–õ–û–ö–ò–†–£–ï–ú - –µ—Å—Ç—å –∫–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏
                channels: processedData.channelsToSubscribe,
                message: '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞–ª—ã'
            };
        }

        // –ï—Å–ª–∏ –µ—Å—Ç—å –∫–∞–Ω–∞–ª—ã, –Ω–æ —Å—Ç–∞—Ç—É—Å –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω - –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ —Å—Ç–∞—Ç—É—Å—É
        if (processedData.channels && processedData.channels.length > 0) {
            const unsubscribedChannels = processedData.channels.filter(ch => ch.needsSubscription);

            if (unsubscribedChannels.length > 0) {
                console.log(`[SMART-SUBGRAM] Found ${unsubscribedChannels.length} unsubscribed channels`);

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–Ω–∞–ª—ã –≤ –ë–î
                await db.executeQuery('DELETE FROM subgram_channels WHERE user_id = $1', [userId]);
                await db.saveSubGramChannels(userId, unsubscribedChannels);

                return {
                    state: SUBGRAM_STATES.HAS_CHANNELS,
                    shouldBlock: true, // –ë–õ–û–ö–ò–†–£–ï–ú - –µ—Å—Ç—å –∫–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏
                    channels: unsubscribedChannels,
                    message: '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞–ª—ã'
                };
            }
        }

        if (processedData.status === 'ok' && processedData.code === 200) {
            // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã –ò–õ–ò –∫–∞–Ω–∞–ª–æ–≤ –Ω–µ—Ç
            console.log('[SMART-SUBGRAM] Status OK - user is subscribed or no channels available');
            return {
                state: SUBGRAM_STATES.ALL_SUBSCRIBED,
                shouldBlock: false,
                channels: [],
                message: '–ü–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –≤—Å–µ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞–ª—ã'
            };
        }

        // 5. –ù–µ—Ç –∫–∞–Ω–∞–ª–æ–≤ - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º
        console.log('[SMART-SUBGRAM] No channels available - this is normal');
        return {
            state: SUBGRAM_STATES.NO_CHANNELS,
            shouldBlock: false, // –ùÔøΩÔøΩ –±–ª–æ–∫–∏—Ä—É–µ–º - –ø—Ä–æ—Å—Ç–æ –Ω–µ—Ç —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
            channels: [],
            message: '–°–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞–ª—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã - –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω'
        };

    } catch (error) {
        console.error('[SMART-SUBGRAM] Critical error checking state:', error);
        return {
            state: SUBGRAM_STATES.API_ERROR,
            shouldBlock: false, // –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–∏ –æ—à–∏–±–∫–µ
            channels: [],
            message: '–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤ - –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω',
            error: error.message
        };
    }
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω—É–∂–Ω–æ –ª–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É
 * @param {number} userId - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Object} –†–µ—à–µ–Ω–∏–µ –æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ
 */
async function shouldBlockBotAccess(userId) {
    try {
        const subgramState = await getSubGramState(userId);
        
        console.log(`[SMART-SUBGRAM] Access decision for user ${userId}: state=${subgramState.state}, shouldBlock=${subgramState.shouldBlock}`);

        return {
            shouldBlock: subgramState.shouldBlock,
            reason: subgramState.state,
            channels: subgramState.channels,
            message: subgramState.message,
            state: subgramState
        };

    } catch (error) {
        console.error('[SMART-SUBGRAM] Error checking bot access:', error);
        // –ü—Ä–∏ –æ—à–∏–±–∫–µ –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø
        return {
            shouldBlock: false,
            reason: 'error_allow_access',
            channels: [],
            message: '–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ - –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω',
            error: error.message
        };
    }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏—Ö –∫–∞–Ω–∞–ª–∞—Ö –¥–ª—è –ø–æ–∫–∞–∑–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
 * @param {number} userId - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Object} –°–æ–æ–±—â–µ–Ω–∏–µ –∏ –∫–Ω–æ–ø–∫–∏
 */
async function getSubscriptionMessage(userId) {
    try {
        const accessCheck = await shouldBlockBotAccess(userId);

        // –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è
        if (!accessCheck.shouldBlock) {
            console.log(`[SMART-SUBGRAM] Access allowed for user ${userId}: ${accessCheck.reason}`);
            return {
                accessAllowed: true,
                reason: accessCheck.reason,
                message: accessCheck.message
            };
        }

        // –ï—Å–ª–∏ –µ—Å—Ç—å –∫–∞–Ω–∞–ª—ã –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ - —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        const channels = accessCheck.channels;
        
        let message = 'üéØ **–°–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞ÔøΩÔøΩ—ã**\n\n';
        message += '–î–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞–ª—ã:\n\n';

        let buttons = [];

        channels.forEach((channel, index) => {
            message += `${index + 1}. ${channel.name}\n`;
            buttons.push([{
                text: `üíé ${channel.name}`,
                url: channel.link
            }]);
        });

        message += '\nüìå –ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –ø—Ä–æ–≤–µ—Ä–∫–∏';
        buttons.push([{ text: '‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏', callback_data: 'check_subgram_subscriptions' }]);

        return {
            accessAllowed: false,
            message: message,
            buttons: buttons,
            channelsCount: channels.length
        };

    } catch (error) {
        console.error('[SMART-SUBGRAM] Error getting subscription message:', error);
        return {
            accessAllowed: true, // –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ä–∞–∑—Ä–µ—à–∞–µ–º –¥–æ—Å—Ç—É–ø
            reason: 'error_allow_access',
            message: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏—Ö –∫–∞–Ω–∞–ª–æ–≤ - –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω'
        };
    }
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ªÔøΩÔøΩ –Ω–∞ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–µ –∫–∞–Ω–∞–ª—ã
 * @param {Object} bot - –≠–∫–∑–µ–º–ø–ª—è—Ä Telegram –±–æ—Ç–∞
 * @param {number} userId - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Object} –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏
 */
async function checkUserSubscriptions(bot, userId) {
    try {
        console.log(`[SMART-SUBGRAM] Checking subscriptions for user ${userId}`);

        // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        const savedChannels = await db.executeQuery(`
            SELECT * FROM subgram_channels
            WHERE user_id = $1
            AND created_at > NOW() - INTERVAL '2 hours'
            ORDER BY created_at DESC
        `, [userId]);

        if (!savedChannels.rows || savedChannels.rows.length === 0) {
            console.log('[SMART-SUBGRAM] No saved channels to check - refreshing state');
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            const newState = await getSubGramState(userId);
            return {
                allSubscribed: !newState.shouldBlock,
                channels: newState.channels,
                refreshed: true
            };
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∫ÔøΩÔøΩ–Ω–∞–ª—ã
        let allSubscribed = true;
        const checkedChannels = [];

        for (const channelData of savedChannels.rows) {
            let isSubscribed = false;
            let canCheck = true;

            try {
                // –ò–∑–≤–ª–µ–∫–∞–µ–º username –∫–∞–Ω–∞–ª–∞ –∏–∑ —Å—Å—ã–ª–∫–∏
                let channelToCheck = channelData.channel_link;
                if (channelData.channel_link.includes('t.me/')) {
                    const match = channelData.channel_link.match(/t\.me\/([^\/\?]+)/);
                    if (match) {
                        channelToCheck = '@' + match[1];
                    }
                }

                const member = await bot.getChatMember(channelToCheck, userId);
                isSubscribed = !(member.status === 'left' || member.status === 'kicked');

            } catch (error) {
                console.log(`[SMART-SUBGRAM] Cannot check channel ${channelData.channel_link}: ${error.message}`);
                // –ü—Ä–∏ –æ—à–∏–±–∫–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—á–∏—Ç–∞–µ–º –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º
                isSubscribed = true;
                canCheck = false;
            }

            if (!isSubscribed) {
                allSubscribed = false;
            }

            checkedChannels.push({
                link: channelData.channel_link,
                name: channelData.channel_name,
                subscribed: isSubscribed,
                canCheck: canCheck
            });
        }

        console.log(`[SMART-SUBGRAM] Subscription check result: ${checkedChannels.length} channels, allSubscribed: ${allSubscribed}`);

        return {
            allSubscribed: allSubscribed,
            channels: checkedChannels,
            checkedCount: checkedChannels.length
        };

    } catch (error) {
        console.error('[SMART-SUBGRAM] Error checking subscriptions:', error);
        return {
            allSubscribed: true, // –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ä–∞–∑—Ä–µ—à–∞–µ–º –¥–æ—Å—Ç—É–ø
            channels: [],
            error: error.message
        };
    }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ—Å—Ç–æ—è–Ω–∏–π SubGram –¥–ª—è –∞–¥–º–∏–Ω–∞
 * @returns {Object} –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
 */
async function getSubGramStats() {
    try {
        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ API –∑–∞–ø—Ä–æ—Å–æ–≤ –∑–∞ 24 —á–∞—Å–∞
        const apiStats = await db.executeQuery(`
            SELECT
                COUNT(*) as total_requests,
                COUNT(CASE WHEN success = true THEN 1 END) as successful_requests,
                COUNT(CASE WHEN success = false THEN 1 END) as failed_requests,
                COUNT(CASE WHEN api_status = 'ok' AND api_code = 200 THEN 1 END) as all_subscribed_responses,
                COUNT(CASE WHEN api_status = 'warning' THEN 1 END) as has_channels_responses,
                COUNT(DISTINCT user_id) as unique_users
            FROM subgram_api_requests
            WHERE created_at > NOW() - INTERVAL '24 hours'
            AND request_type LIKE '%smart%'
        `);

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
        const channelStats = await db.executeQuery(`
            SELECT
                COUNT(DISTINCT user_id) as users_with_channels,
                COUNT(*) as total_saved_channels,
                COUNT(CASE WHEN created_at > NOW() - INTERVAL '1 hour' THEN 1 END) as recent_channels
            FROM subgram_channels
        `);

        return {
            api: apiStats.rows[0] || {},
            channels: channelStats.rows[0] || {},
            timestamp: new Date().toISOString()
        };

    } catch (error) {
        console.error('[SMART-SUBGRAM] Error getting stats:', error);
        return { error: error.message };
    }
}

module.exports = {
    SUBGRAM_STATES,
    getSubGramState,
    shouldBlockBotAccess,
    getSubscriptionMessage,
    checkUserSubscriptions,
    getSubGramStats
};
